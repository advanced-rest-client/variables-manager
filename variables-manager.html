<!--
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../events-target-behavior/events-target-behavior.html">
<script>
/**
 * A manager for environments and variables. Non UI element that manages variables
 * state and handle data storage.
 *
 * ### Example
 *
 * ```html
 * <variables-manager></variables-manager>
 * ```
 *
 * This element is designed to work with browser's event system. That means that
 * each operation can be done by dispatching
 * [CustomEvent](https://developer.mozilla.org/en/docs/Web/API/CustomEvent).
 *
 * **Important** Events that request data update (create/update/delete) must be
 * cancellable. Otherwise the element will not handle the event at all.
 *
 * When the update event is handled it is cancelled so 1) other managers that
 * exists in the DOM and listens fo the same event will not execute change 2)
 * after execution the manager dispatches the same event which is not cancellable.
 * UI element and other relevant parts of the application should handle only the
 * event that is not cancellable because it contains data **after** the update
 * has been stored in the datastore.
 *
 * ### Example
 *
 * ```javascript
 * // requesting to create an environment
 * const e = new CustomEvent('environment-updated', {
 *    bubbles: true,
 *    composed: true,
 *    cancelable: true,
 *    detail: {
 *      name: 'Test environment'
 *    }
 * });
 * document.dispatchEvent(e);
 * console.log(e.defaultPrevented); // true
 * ```
 *
 * The event requesting data change is cancelled and propagation of the
 * event is stopped. The same script should listen for the same event to
 * check for data update:
 *
 * ```javascript
 *
 * window.addEventListener('environment-updated', function(e) {
 *    if (e.cancelable) {
 *      // This event requesting data change. We shouldn't be interested in this
 *      // event.
 *      return;
 *    }
 *    const environment = e.detail.value;
 *    console.log(environment._id, environment._rev);
 * });
 * ```
 *
 * Updated object will have updated `_rev` property and `_id`. This are
 * [PouchDb](https://pouchdb.com/api.html) properties to identify data in the
 * datastore.
 *
 * ## Events API
 *
 * ### selected-environment-changed
 *
 * Changes currently selected environment in the manager. This event doesn't have
 * to be cancelable. The change trigges request to read variables for new
 * environment so `variables-list-changed` event is expected to be fired.
 *
 * #### Properties
 *
 * `value` (`string`) - Selected environment name
 *
 * ### environment-updated
 *
 * Updates or creates new environment. This event have to be cancelable.
 * If the `value` property contains `_id` then the object will be updated.
 *
 * #### Properties
 *
 * `value` (`object`) - Environment datastore object.
 *
 * ### environment-deleted
 *
 * Deletes an environment. This event have to be cancelable.
 *
 * #### Properties
 * `value` (`string`) - The `_id` property of the environment object.
 *
 * ### environment-current
 *
 * Request for current environment information. This event have to be cancelable.
 * The manager will set a `value` property on the details object so the event
 * source should read it after the event is dispatched.
 *
 * Note: you have to set a detail object or otherwise it won't be created after
 * the event is dispatched.
 *
 * ```javascript
 * const e = new CustomEvent('environment-current', {
 *    bubbles: true,
 *    composed: true,
 *    cancelable: true,
 *    detail: {}
 * });
 * document.dispatchEvent(e);
 * if (e.defaultPrevented) {
 *    console.log(e.detail.value); // Current environment
 * }
 * ```
 *
 * ### environment-list
 *
 * Request for current environments list information. This event have to be
 * cancelable. The manager will set a `value` property on the details object so
 * the event source should read it after the event is dispatched.
 *
 * Note: you have to set a detail object or otherwise it won't be created after
 * the event is dispatched.
 *
 * Note: The value contains a list of user created environments (without
 * the `default` environment). Therefore it can be `undefined` or empty array.
 *
 * ```javascript
 * const e = new CustomEvent('environment-list', {
 *    bubbles: true,
 *    composed: true,
 *    cancelable: true,
 *    detail: {}
 * });
 * document.dispatchEvent(e);
 * if (e.defaultPrevented) {
 *    console.log(e.detail.value); // All available environments.
 * }
 * ```
 *
 * ### variable-updated
 *
 * Updates or creates new variable. This event have to be cancelable.
 * If the `value` property contains `_id` then the object will be updated.
 *
 * #### Properties
 *
 * `value` (`object`) - Variable datastore object.
 *
 * The object must contain `variable` (variable name), `value` (it's body) and
 * `environment` properties. Otherwise an error will be throw.
 *
 * ### variable-deleted
 *
 * Deletes an environment. This event have to be cancelable.
 *
 * #### Properties
 *
 * `value` (`string`) - The `_id` property of the variable object.
 *
 * ### variable-list
 *
 * Request for current variables list information. This event have to be
 * cancelable. The manager will set a `value` property on the details object so
 * the event source should read it after the event is dispatched.
 *
 * Note: you have to set a detail object or otherwise it won't be created after
 * the event is dispatched.
 *
 * Note: The value contains a list of user created variables. Therefore it can be
 * `undefined` or empty array.
 *
 * Note: Additional `environment` property is set to the `detail` object to indicate
 * to which environment the variables belongs.
 *
 * ```javascript
 * const e = new CustomEvent('variable-list', {
 *    bubbles: true,
 *    composed: true,
 *    cancelable: true,
 *    detail: {}
 * });
 * document.dispatchEvent(e);
 * if (e.defaultPrevented) {
 *    console.log(e.detail.value); // All available variables.
 *    console.log(e.detail.environment); // Environment name.
 * }
 * ```
 *
 * ## New in version 2
 *
 * - PouchDB is optional dependency. Add your own version of PouchDB to use the
 * component.
 * - `environment-updated`, `environment-deleted`, `variable-updated`, and
 * `variable-deleted` events always set `result` on the detail object with the
 * promise. It does not set `error` property anymore.
 *
 * @memberof LogicElements
 * @customElement
 * @polymer
 * @demo demo/index.html
 * @appliesMixin ArcBehaviors.EventsTargetBehavior
 */
class VariablesManager extends ArcBehaviors.EventsTargetBehavior(Polymer.Element) {
  static get is() { return 'variables-manager'; }
  static get properties() {
    return {
      /**
       * Currently loaded environemnt.
       */
      environment: {
        type: String,
        value: 'default',
        observer: '_environmentChanged'
      },
      /**
       * List of available environments (except for "default").
       */
      environments: {
        type: Array,
        notify: false
      },
      /**
       * List of variables associated with current `environment`.
       */
      variables: Array,
      /**
       * List of variables that overrides all existing variables
       * (system or app) and exists only in memory.
       */
      inMemVariables: Array
    };
  }

  static get observers() {
    return [
      '_environmentsChanged(environments.*)',
      '_variablesChanged(variables.*)',
      '_inMemVariablesChanged(inMemVariables.*)'
    ];
  }
  /**
   * Returns a list of system variables.
   * This returns a value only if the element is executed in node environment.
   * @return {Array} Variables model for system variables or empty array
   * if not in node environment.
   */
  get systemVariables() {
    const value = [];
    if (typeof process === 'undefined' || typeof process.env === 'undefined') {
      return value;
    }
    const name = this.environemnt;
    Object.keys(process.env).forEach(function(env) {
      const obj = {
        variable: env,
        value: process.env[env],
        enabled: true,
        environment: name,
        sysVar: true
      };
      value.push(obj);
    });
    return value;
  }
  /**
   * Handler to the environments database.
   *
   * @return {Object}
   */
  get _envDb() {
    /* global PouchDB */
    return new PouchDB('variables-environments');
  }
  /**
   * Handler to the variables database.
   *
   * @return {Object}
   */
  get _varDb() {
    return new PouchDB('variables');
  }

  constructor() {
    super();
    this._envChnageHandler = this._envChnageHandler.bind(this);
    this._envUpdateHandler = this._envUpdateHandler.bind(this);
    this._envDeleteHandler = this._envDeleteHandler.bind(this);
    this._envGetCurrentHandler = this._envGetCurrentHandler.bind(this);
    this._envListHandler = this._envListHandler.bind(this);
    this._varUpdateHandler = this._varUpdateHandler.bind(this);
    this._varDeleteHandler = this._varDeleteHandler.bind(this);
    this._varListHandler = this._varListHandler.bind(this);
    this._dataImportHandler = this._dataImportHandler.bind(this);
    this._varStoreActionHandler = this._varStoreActionHandler.bind(this);
    this._varUpdateActionHandler = this._varUpdateActionHandler.bind(this);
  }

  connectedCallback() {
    super.connectedCallback();
    this._updateEnvironmentsList();
  }

  _attachListeners(node) {
    node.addEventListener('selected-environment-changed', this._envChnageHandler);
    node.addEventListener('environment-updated', this._envUpdateHandler);
    node.addEventListener('environment-deleted', this._envDeleteHandler);
    node.addEventListener('environment-current', this._envGetCurrentHandler);
    node.addEventListener('environment-list', this._envListHandler);
    node.addEventListener('variable-updated', this._varUpdateHandler);
    node.addEventListener('variable-deleted', this._varDeleteHandler);
    node.addEventListener('variable-list', this._varListHandler);
    node.addEventListener('data-imported', this._dataImportHandler);
    node.addEventListener('variable-store-action', this._varStoreActionHandler);
    node.addEventListener('variable-update-action', this._varUpdateActionHandler);
    if (this.environment) {
      this.dispatchEvent(new CustomEvent('selected-environment-changed', {
        composed: true,
        bubbles: true,
        detail: {
          value: this.environment
        }
      }));
    }
  }

  _detachListeners(node) {
    node.removeEventListener('selected-environment-changed', this._envChnageHandler);
    node.removeEventListener('environment-updated', this._envUpdateHandler);
    node.removeEventListener('environment-deleted', this._envDeleteHandler);
    node.removeEventListener('environment-current', this._envGetCurrentHandler);
    node.removeEventListener('environment-list', this._envListHandler);
    node.removeEventListener('variable-updated', this._varUpdateHandler);
    node.removeEventListener('variable-deleted', this._varDeleteHandler);
    node.removeEventListener('variable-list', this._varListHandler);
    node.removeEventListener('data-imported', this._dataImportHandler);
    node.removeEventListener('variable-store-action', this._varStoreActionHandler);
    node.removeEventListener('variable-update-action', this._varUpdateActionHandler);
  }
  /**
   * Handler for the `environment` property change.
   *
   * Fires a `selected-environment-changed` custom event and updates list of variables
   * in the environment.
   */
  _environmentChanged(environment) {
    this.variables = undefined;
    if (!this.__cancelEnvChangeEvent) {
      this.dispatchEvent(new CustomEvent('selected-environment-changed', {
        composed: true,
        bubbles: true,
        detail: {
          value: environment
        }
      }));
    }
    if (environment) {
      this._updateVariablesList();
    }
  }
  /**
   * Handler for the `environments` property change.
   *
   * Fires a `environments-list-changed` custom event.
   */
  _environmentsChanged(record) {
    if (this._cancelEnvironmentsChangeEvent) {
      return;
    }
    let value = record && record.base;
    if (value) {
      // Need a copy of the less otherwise notification system
      // in elements that uses this list won't work.
      // Because complex object are passed by refenrence any change to the
      // object elsewhere would result with change here and this is bad.
      value = value.map((item) => Object.assign({}, item));
    }
    this.dispatchEvent(new CustomEvent('environments-list-changed', {
      composed: true,
      bubbles: true,
      detail: {
        value: value
      }
    }));
  }
  /**
   * Handler for the `variables` property change.
   * Fires a `variables-list-changed` custom event.
   */
  _variablesChanged() {
    if (this._cancelVariablesChangeEvent) {
      return;
    }
    this._notifyVarsListChanged();
  }

  _inMemVariablesChanged(record) {
    if (this._cancelVariablesChangeEvent) {
      return;
    }
    if (!record || record.path === 'inMemVariables.splices') {
      return;
    }
    this._notifyVarsListChanged();
  }
  /**
   * Lists app, sys and in mem variables in single array.
   * @return {Array<Object>} List of all variables.
   */
  listAllVariables() {
    const variables = this.variables;
    const memVariables = this.inMemVariables;
    const result = [];
    const names = [];
    if (variables && variables.length) {
      variables.forEach((item) => {
        names.push(item.variable);
        result.push(Object.assign({}, item));
      });
    }
    if (memVariables) {
      for (let i = 0, len = memVariables.length; i < len; i++) {
        const item = Object.assign({}, memVariables[i]);
        if (names.indexOf(item.variable) !== -1) {
          for (let j = 0, resLen = result.length; j < resLen; j++) {
            if (result[j].variable === item.variable) {
              result[j] = item;
              break;
            }
          }
        } else {
          result.push(item);
        }
      }
    }
    return result;
  }
  /**
   * Combines both app variables and in memory variables
   * and informs listeners about the change.
   */
  _notifyVarsListChanged() {
    this.dispatchEvent(new CustomEvent('variables-list-changed', {
      composed: true,
      bubbles: true,
      detail: {
        value: this.listAllVariables(),
        environment: this.environment
      }
    }));
  }
  /**
   * Get's a list of environments and updates the `environments` property.
   *
   * This task is asynchronus.
   */
  _updateEnvironmentsList() {
    return this.listEnvironments()
    .then((environments) => this.set('environments', environments))
    .catch((cause) => this._handleException(cause));
  }
  /**
   * Updates the list of variables for current environment.
   *
   * This task is asynchronus.
   */
  _updateVariablesList() {
    const currentEnv = this.environment;
    if (!currentEnv) {
      return;
    }
    this.listVariables(currentEnv)
    .then((variables) => {
      if (currentEnv !== this.environment) {
        // In some cases (changing environemnt right after initialization)
        // this may actually happen. Especially on slow IE.
        let msg = 'Skipping setting variables list. Environment changed ';
        msg += 'from %s to %s';
        console.info(msg, currentEnv, this.environemnt);
        return;
      }
      variables = variables || [];
      variables = variables.concat(this.systemVariables || []);
      this.set('variables', variables);
    })
    .catch((cause) => this._handleException(cause));
  }
  /**
   * Lists all user defined environments.
   *
   * @return {Promise} Resolved promise with the list of environments.
   */
  listEnvironments() {
    return this._envDb.allDocs({
      // jscs:disable
      include_docs: true
      // jscs:enable
    })
    .then((docs) => docs.rows.map((i) => i.doc));
  }
  /**
   * Refreshes list of variables for the `environemnt`.
   *
   * @param {?String} environemnt Name of the environment to get the variables
   * from. If not set then `default` fill be used.
   * @return {Promise} Resolved promise with the list of variables for the
   * environment.
   */
  listVariables(environment) {
    environment = environment || 'default';
    environment = environment.toLowerCase();
    return this._varDb.allDocs({
      // jscs:disable
      include_docs: true
      // jscs:enable
    })
    .then((docs) => {
      return docs.rows.filter((item) => {
        if (!item.doc.environment) {
          return false;
        }
        return item.doc.environment.toLowerCase() === environment;
      })
      .map((item) => item.doc);
    });
  }
  /**
   * Handles exceptions when occur by logging them to the console and
   * sending an analytics report.
   *
   * @param {Error} cause An error object with description.
   */
  _handleException(cause) {
    this.dispatchEvent(new CustomEvent('send-analytics', {
      composed: true,
      bubbles: true,
      detail: {
        type: 'exception',
        description: 'Listing environmants ' + cause.message,
        fatal: false
      }
    }));
    console.error(cause);
  }
  /**
   * A handler for the `selected-environment-changed` custom event.
   * Updates the `environment` property if the event was sent by other elemenet
   * than `this`.
   */
  _envChnageHandler(e) {
    if (e.composedPath()[0] === this) {
      return;
    }
    this.__cancelEnvChangeEvent = true;
    this.set('environment', e.detail.value);
    this.__cancelEnvChangeEvent = false;
  }
  /**
   * Handler for the `data-imported` custom event. Refreshes list of environmants
   * and variables.
   */
  _dataImportHandler() {
    this._updateEnvironmentsList()
    .then(() => this._updateVariablesList());
  }

  _eventCancelled(e) {
    const status = e.defaultPrevented || !e.cancelable;
    if (!status) {
      if (e.composedPath()[0] === this) {
        return true;
      }
    }
    return status;
  }

  _cancelEvent(e) {
    e.preventDefault();
    e.stopPropagation();
  }
  /**
   * A handler for the `environment-updated` custom event.
   * Updates the environment in the data store.
   *
   * The `environment-updated` custom event should be cancellable or the event
   * won't be handled at all.
   */
  _envUpdateHandler(e) {
    if (this._eventCancelled(e)) {
      return;
    }
    this._cancelEvent(e);
    e.detail.result = this.updateEnvironment(e.detail.value);
  }
  /**
   * A handler for the `environment-deleted` custom event.
   * Deletes a variable in the data store.
   *
   * The `environment-deleted` custom event should be cancellable or the event
   * won't be handled at all.
   *
   * The delete function fires non cancellable `environment-deleted` custom
   * event so the UI components can use it to update their values.
   */
  _envDeleteHandler(e) {
    if (this._eventCancelled(e)) {
      return;
    }
    this._cancelEvent(e);
    e.detail.result = this.deleteEnvironment(e.detail.value);
  }
  /**
   * A handler for the `environment-current` custom event.
   * Adds a `value` propety of the event `detail` object with the name of the
   * environment.
   *
   * The `environment-current` custom event should be cancellable or the event
   * won't be handled at all.
   */
  _envGetCurrentHandler(e) {
    if (this._eventCancelled(e)) {
      return;
    }
    this._cancelEvent(e);
    e.detail.value = this.environment;
  }
  /**
   * A handler for the `environment-list` custom event.
   * Adds a `value` propety of the event `detail` object with the array of the
   * user defined environments objects. Each item is a PouchDb data store item
   * (with `_id` and `_rev`).
   *
   * The `value` set on the details object can be undefined if the user haven't
   * defined any environments or if the manager haven't restored the list yet.
   * In the later case the event target element should listen for
   * `environments-list-changed` event to update the list of available environments.
   *
   * The `environment-current` custom event should be cancellable or the event
   * won't be handled at all.
   */
  _envListHandler(e) {
    if (this._eventCancelled(e)) {
      return;
    }
    this._cancelEvent(e);
    e.detail.value = this.environments;
  }
  /**
   * Updates an environment value.
   *
   * If the `value` doesn't contains the `_id` property a new environment will
   * be created. The `_rev` property will be always updated to the latest value.
   *
   * After finish this method sends the `environment-updated` event that can't
   * be cancelled so other managers that are present in the DOM will not update
   * the value.
   *
   * @param {Object} data A PouchDB object to be stored. It should contain the
   * `_id` property if the object is about to be updated. If the `_id` doesn't
   * exists a new object is created.
   * @return {Promise}
   */
  updateEnvironment(data) {
    if (!data.name) {
      const error = new Error('Can\'t create an environment without the name.');
      return Promise.reject(error);
    }
    if (!data.created) {
      data.created = Date.now();
    }
    if (data.created instanceof Date) {
      data.created = data.created.getTime();
    }
    let promise;
    let oldName;
    if (!data._id) {
      // creates new environment
      promise = Promise.resolve(data);
    } else {
      promise = this._envDb.get(data._id)
      .then(function(doc) {
        if (data.name !== doc.name) {
          oldName = doc.name;
          doc.name = data.name;
        }
        data._rev = doc._rev;
        return data;
      })
      .catch(function(error) {
        if (error.status === 404) {
          delete data._id;
          return data;
        }
        throw new Error(error.message);
      });
    }
    return promise
    .then((doc) => this._envDb[!!(doc._id) ? 'put' : 'post'](doc))
    .then((result) => {
      if (!result.ok) {
        this._handleException(result);
        throw new Error(result.message);
      }
      data._id = result.id;
      data._rev = result.rev;
      this.dispatchEvent(new CustomEvent('environment-updated', {
        composed: true,
        bubbles: true,
        detail: {
          value: Object.assign({}, data)
        }
      }));
      this.__updateEnvironmentItem(data);
      if (oldName) {
        this.__updateEnvironmentName(oldName, data);
      }
      return data;
    })
    .catch((cause) => {
      this._handleException(cause);
      throw new Error(cause.message);
    });
  }
  /**
   * Updated the item in the `environments` array propery.
   * Either add new property or updates existing one.
   *
   * @param {Object} data The PouchDB object.
   */
  __updateEnvironmentItem(data) {
    const envs = this.environments;
    this._cancelEnvironmentsChangeEvent = true;
    if (!envs) {
      this.set('environments', [data]);
      this._cancelEnvironmentsChangeEvent = false;
      return;
    }
    const index = envs.findIndex((item) => item._id === data._id);
    if (~index) {
      this.set(['environments', index], data);
    } else {
      this.push('environments', data);
    }
    this._cancelEnvironmentsChangeEvent = false;
  }
  /**
   * A special case when the name of the environment changes.
   * It updates any related to this environment variables.
   *
   * If this is current environment it also changes its name.
   *
   * @param {String} oldName Name of the environment befoe the change
   * @param {String} data Updated data store entry
   */
  __updateEnvironmentName(oldName, data) {
    const isCurrent = oldName === this.environment;
    let promise;
    if (isCurrent) {
      promise = Promise.resolve(this.variables);
    } else {
      promise = this.listVariables(oldName);
    }
    promise.then((variables) => {
      if (!variables || !variables.length) {
        return;
      }
      variables = variables.map(function(item) {
        item.environment = data.name;
        return item;
      });
      return this._varDb.bulkDocs(variables);
    })
    .then((result) => {
      if (!result || !result.length) {
        return;
      }
      if (isCurrent) {
        this.set('environment', data.name);
        // setter will update list of variables
      }
    });
  }
  /**
   * Deletes an environment from the data store.
   *
   * After updating the data store this method sends the `environment-deleted`
   * event that can't be cancelled so other managers that are present in the DOM
   * will not update the value again. If you don't need updated `_rev` you don't
   * have to listen for this event.
   *
   * Because this function changes the `environments` array the
   * `environments-list-changed` event is fired alongside the `environment-deleted`
   * event.
   *
   * @param {Object} id The PouchDB `_id` property of the object to delete.
   * @return {Promise}
   */
  deleteEnvironment(id) {
    if (!id) {
      const error = new Error('Can\'t delete an environment without its id');
      return Promise.reject(error);
    }
    let environment;
    const db = this._envDb;
    return db.get(id)
    .then(function(doc) {
      environment = doc.name;
      return db.remove(doc);
    })
    .then((result) => {
      if (!result.ok) {
        this._handleException(result);
        throw new Error(result.message);
      }
      // update list of environments.
      if (this.environments) {
        const index = this.environments.findIndex((item) => item._id === id);
        if (~index) {
          this._cancelEnvironmentsChangeEvent = true;
          this.splice('environments', index, 1);
          this._cancelEnvironmentsChangeEvent = false;
        }
      }
      const detail = {
        value: result.id,
        rev: result.rev
      };
      this.dispatchEvent(new CustomEvent('environment-deleted', {
        composed: true,
        bubbles: true,
        detail: detail
      }));
      setTimeout(() => this._afterDeleteEnvironment(environment), 1);
      return detail;
    })
    .catch((error) => {
      this._handleException(error);
      throw new Error(error.message);
    });
  }
  /**
   * To be called after the environment has been deleted. It clears variables
   * for the environment and if the environment is currently loaded environment
   * then it clear cuerrent data.
   *
   * @param {String} environment The environment name.
   */
  _afterDeleteEnvironment(environment) {
    if (!environment) {
      return;
    }
    environment = environment.toLowerCase();
    if (environment === 'default') {
      return;
    }

    let promise;
    const currentEnvironment = environment === this.environment;
    if (currentEnvironment) {
      promise = Promise.resolve(this.variables);
    } else {
      promise = this.listVariables(environment);
    }

    return promise
    .then((variables) => {
      if (currentEnvironment) {
        this.environment = 'default';
      }
      // It is possible to not have a result here.
      if (!variables) {
        return;
      }
      variables = variables.map(function(doc) {
        doc._deleted = true;
        return doc;
      });
      return this._envDb.bulkDocs(variables);
    })
    // This will not fire `variable-deleted` event because it doesn't make
    // sense. UIs and managers should relay on `environment-deleted` event.
    .catch((error) => {
      this._handleException(error);
      throw new Error(error.message);
    });
  }
  /**
   * A handler for the `variable-updated` custom event.
   * Updates the variable in the data store.
   *
   * The `variable-updated` custom event should be cancellable or the event
   * won't be handled at all.
   */
  _varUpdateHandler(e) {
    if (this._eventCancelled(e)) {
      return;
    }
    this._cancelEvent(e);
    e.detail.result = this.updateVariable(e.detail.value);
  }
  /**
   * Deletes a variable from the data store.
   *
   * If the `value` doesn't contains the `_id` property a new environment will
   * be created. The `_rev` property will be always updated to the latest value.
   *
   * After finish this method sends the `environment-deleted` event that can't
   * be cancelled so other managers that are present in the DOM will not update
   * the value. If you don't need database record updated `_rev` you don't
   * have to listen for this event.
   *
   * Because this function changes the `environments` array the
   * `environments-list-changed` event is fired alongside the `environment-deleted`
   * event.
   *
   * @param {Object} id The PouchDB `_id` property of the object to delete.
   * @param {?Event} e Optional. If it is called from the event handler, this
   * is the event object. If initial validation fails then it will set `error`
   * property on the `detail` object.
   */
  _varDeleteHandler(e) {
    if (this._eventCancelled(e)) {
      return;
    }
    this._cancelEvent(e);
    e.detail.result = this.deleteVariable(e.detail.value);
  }
  /**
   * A handler for the `variable-list` custom event.
   *
   * Adds a `value` propety of the event `detail` object with the array of the
   * variables restored for current environment. Each item is a PouchDb data
   * store item (with `_id` and `_rev`).
   *
   * The `value` set on the details object can be undefined if the this of
   * variables haven't been read yet or if the yser haven't defined any
   * variable for this environment.
   * In the first case the event target element should listen for
   * `variables-list-changed` event to update the list of available variables for
   * current environment.
   *
   * Additionally it sets the `environment` property on the `detail` object
   * with the name of current environment.
   *
   * List of properties added to the detail object is consistent with the
   * `variables-list-changed` event fired by this event.
   *
   * The `variable-list` custom event should be cancellable or the event
   * won't be handled at all. It's to prohibit handling the event by many
   * managers (if more than one is in the DOM).
   */
  _varListHandler(e) {
    if (this._eventCancelled(e)) {
      return;
    }
    this._cancelEvent(e);
    e.detail.value = this.listAllVariables();
    e.detail.environment = this.environment;
  }
  /**
   * Updates a variable value.
   *
   * If the `value` doesn't contains the `_id` property a new variable will
   * be created. The `_rev` property will be always updated to the latest value
   * so there's no need to set it on the object.
   *
   * After saving the data this method sends the `variable-updated` event that
   * can't be cancelled so other managers that are present in the DOM will not
   * update the value again.
   *
   * @param {Object} data A PouchDB object to be stored. It should contain the
   * `_id` property if the object is about to be updated. If the `_id` doesn't
   * exists a new object is created.
   * @return {Promise}
   */
  updateVariable(data) {
    if (!data.variable) {
      const m = 'Can\'t create a variable without the variable property';
      const error = new Error(m);
      return Promise.reject(error);
    }
    const db = this._varDb;
    let promise;
    if (!data._id) {
      // creates new environment
      promise = Promise.resolve(data);
    } else {
      promise = db.get(data._id)
      .then(function(doc) {
        data._rev = doc._rev;
        return data;
      })
      .catch(function(error) {
        if (error.status === 404) {
          delete data._id;
          return data;
        }
        throw new Error(error.message);
      });
    }
    return promise
    .then((doc) => db[doc._id ? 'put' : 'post'](doc))
    .then((result) => {
      if (!result.ok) {
        this._handleException(result);
        throw new Error(result.message);
      }
      data._id = result.id;
      data._rev = result.rev;
      this.dispatchEvent(new CustomEvent('variable-updated', {
        composed: true,
        bubbles: true,
        detail: {
          value: Object.assign({}, data)
        }
      }));
      this.__updateVariableItem(data);
      return data;
    });
  }

  /**
   * Updated the item in the `variables` array propery.
   * Either add new property or updates existing one.
   *
   * @param {Object} data The PouchDB object.
   */
  __updateVariableItem(data) {
    if (data.environment !== this.environment) {
      return;
    }
    this._cancelVariablesChangeEvent = true;
    const vars = this.variables;
    if (!vars) {
      this.set('variables', [data]);
      this._cancelVariablesChangeEvent = false;
      return;
    }
    const index = vars.findIndex((item) => item._id === data._id);
    if (~index) {
      this.set(['variables', index], data);
    } else {
      this.push('variables', data);
    }
    this._cancelVariablesChangeEvent = false;
  }
  /**
   * Deletes a variable from the data store.
   *
   * After updating the data store this method sends the `variable-deleted`
   * event that can't be cancelled so other managers that are present in the DOM
   * will not update the value again. If you don't need updated `_rev` you don't
   * have to listen for this event.
   *
   * Because this function changes the `variables` array the
   * `variables-list-changed` event is fired alongside the `variable-deleted`
   * event.
   *
   * @param {Object} id The PouchDB `_id` property of the object to delete.
   * @return {Promise}
   */
  deleteVariable(id) {
    if (!id) {
      const error = new Error('Can\'t delete a variable without its id');
      return Promise.reject(error);
    }
    const db = this._varDb;
    return db.get(id)
    .then((doc) =>  db.remove(doc))
    .then((result) => {
      if (!result.ok) {
        return this._handleException(result);
      }
      // update list of environments.
      if (this.variables) {
        const index = this.variables.findIndex((item) => item._id === id);
        if (~index) {
          this._cancelVariablesChangeEvent = true;
          this.splice('variables', index, 1);
          this._cancelVariablesChangeEvent = false;
        }
      }
      const detail = {
        value: result.id,
        rev: result.rev
      };
      this.dispatchEvent(new CustomEvent('variable-deleted', {
        composed: true,
        bubbles: true,
        detail: detail
      }));
      return detail;
    })
    .catch((error) => {
      this._handleException(error);
      throw new Error(error.message);
    });
  }

  _varStoreActionHandler(e) {
    const obj = {
      variable: e.detail.variable,
      value: e.detail.value,
      enabled: true,
      sysVar: false,
      environment: this.environemnt
    };
    if (!this.variables) {
      e.detail.result = this.updateVariable(obj);
      return e.detail.result;
    }
    const index = this.variables.findIndex((item) => item.variable === obj.variable);
    if (index === -1) {
      e.detail.result = this.updateVariable(obj);
      return e.detail.result;
    } else {
      this.variables[index].value = obj.value;
      e.detail.result = this.updateVariable(this.variables[index]);
      return e.detail.result;
    }
  }

  _varUpdateActionHandler(e) {
    // in memory variable change - without storing it to the store.
    const obj = {
      variable: e.detail.variable,
      value: e.detail.value,
      enabled: true,
      sysVar: false,
      environment: '*'
    };
    if (!this.inMemVariables) {
      this.set('inMemVariables', [obj]);
      return;
    }
    const index = this.inMemVariables.findIndex((item) => item.variable === obj.variable);
    if (index === -1) {
      this.push('inMemVariables', obj);
    } else {
      this.set(['inMemVariables', index, 'value'], obj.value);
    }
  }

  /**
   * Fired when selected environment has changed.
   * This event is not fired if the change has been causes by the
   * `selected-environment-changed` fired by other element.
   *
   * @event selected-environment-changed
   * @param {String} value Name of the selected environment.
   */

  /**
   * Fired when the list of available custom envrionments have been updated.
   * Usually it means that the element has been initialized or the `environment`
   * property has changed. UIs should update list of available environments from
   * this events.
   *
   * The list do not contain the default environment.
   *
   * @event environments-list-changed
   * @param {Array} value Array of PouchDB items with `_id` and `_rev` that
   * should be present when updating the envitonment.
   */

  /**
   * Fired when the list of variables for current environment has been read
   * and set. UIs should update list of current varables from
   * this events.
   *
   * @event variables-list-changed
   * @param {Array} value Array of PouchDB items with `_id` and `_rev` that
   * should be present when updating the envitonment.
   * @param {String} environment Name of the environment the the variables
   * belongs to.
   */
  /**
   * Fired when the environment has been saved / updated in the data store.
   *
   * Event fired by this element is not cancellable. While request to update
   * an evironment is cancellable (implementations cancels the event so it will
   * be updated only once) this event isn't, to differentiate between this two
   * states. Generally: cancellable event - request for change, not cancellable
   * event - change has been applied to the data in the data store.
   *
   * @event environment-updated
   * @param {Object} value Updated PouchDB document (with new `_rev`).
   */
  /**
   * Fired when the environment has been deleted from the data store.
   *
   * Event fired by this element is not cancellable. While request to delete
   * an evironment is cancellable (implementations cancels the event so it will
   * be deleted only once) this event isn't, to differentiate between this two
   * states. Generally: cancellable event - request for change, not cancellable
   * event - change has been applied to the data in the data store.
   *
   * @event environment-deleted
   * @param {String} value Id of the environment in the data store
   * @param {String} rev Updated `_rev` after the environment was deleted.
   */
  /**
   * Fired when the variable has been added to / updated in the data store.
   *
   * Event fired by this element is not cancellable. While request to delete
   * an evironment is cancellable (implementations cancels the event so it will
   * be deleted only once) this event isn't, to differentiate between this two
   * states. Generally: cancellable event - request for change, not cancellable
   * event - change has been applied to the data in the data store.
   *
   * @event variable-updated
   * @param {Object} value Updated PouchDB document (with new `_rev`).
   */
  /**
   * Fired when the variable has been deleted from the data store.
   *
   * Event fired by this element is not cancellable. While request to delete
   * a variable is cancellable (implementations cancels the event so it will
   * be deleted only once) this event isn't, to differentiate between this two
   * states. Generally: cancellable event - request for change, not cancellable
   * event - change has been applied to the data in the data store.
   *
   * @event variable-deleted
   * @param {String} value Id of the variable in the data store
   * @param {String} rev Updated `_rev` after the variable was deleted.
   */
}
window.customElements.define(VariablesManager.is, VariablesManager);
</script>
